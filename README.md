# enigma
Turing Mod1 final solo project - specs [here](https://backend.turing.io/module1/projects/enigma/index)

## Self Assessment
### Functionality: 3
`Enigma`, `Enigma#encrypt`, `Enigma#decrypt`, and CLI are implemented and based on testing (both via TDD and through CLI trials in terminal), seem to have been done so successfully. I plan to try out the cracking method during intermission.
### Object Oriented Programming - 4
Aside from the required `Enigma` class, I also created a `Key` class and a `Cipher` class. `Key` contains a class method that simply returns a randomly generated key to be implemented if the user has not provided a key themselves. This is separated from `Enigma` because it is an object of its own, not intrinsically tied to `Enigma`. Finally, `Cipher` represents a generic encryption/decryption framework from which `Enigma` - a specific type of encryption/decryption framework - inherits its attributes and methods. Ideally `Cipher` would allow for flexibility in the number/type of shifts it can generate, but because this project only involves `Enigma` and not other types of ciphers and with the YAGNI principle in mind, I have not built out that flexible functionality. Though in the grand scheme it might not be the perfect use-case, I believe I've successfully and thoughtfully implemented inheritance given the context.
### Ruby Conventions and Mechanisms - 4
My code is well-organized, properly indented, spaced, and lines kept reasonable in length. Hashes are utilized to create the A-D keys, offsets, and shifts, as well as the A-D shifted alphabets referenced in the encryption and decryption process. I was curious about the `Array#zip` method, but ultimately found that creating a hash with `:A` - `:D` as keys and the respective shifted alphabets allowed for a more straightforward process of translating each character as it simply required referencing a key, which is known based on the original character - rather than needing to reference multiple indexes. Each alphabet within that hash was created using `#reduce`, which seems appropriate considering the array `@alphabet` was used as the basis for creating a hash. I also used `#map.with_index` to execute the shifting of message characters, which seems appropriate considering the index was necessary in order to identify which shift needed to be used for which character, and the resulting collection was simply a transformation of the original collection of characters. Lastly, my longest method is 7 lines.
### Test Driven Development - 3.5-4
Every method is tested at both unit and integration level and expected behavior is completely verified, including 100% coverage. My `#encrypt` and `#decrypt` methods also test edge cases like encrypting or decrypting messages that include punctuation. Except for in a few cases during the process of refactoring and separating out helper methods, all methods had tests composed before the methods themselves were composed. Additionally, stubs are used to ensure even methods that involve randomization are tested (e.g., `Key::generate`) and to allow for testing without relying on functionality from other methods (e.g., stubbed `Enigma#format_date` and `Key::generate` when testing `Enigma#encrypt` without user-provided date). Because the rubric says "classes can be tested without relying on functionality from other classes", I'm not sure if the second example of stubbing would count toward reaching a 4 - hence the 3.5-4 score.
### Version Control - 3-4
My project has 127 commits and 12 branches, broken down by method and related functionality or editing. I'm pretty sure no commits include multiple pieces of functionality and I believe my commit messages are pretty clear, but that's pretty subjective - hence the 3-4 score.
